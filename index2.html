<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchical Edge Bundling Chart</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .chart-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        .title {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="chart-container">
        <div class="title">Research Paper Network Visualization</div>
        <div id="chart"></div>
    </div>

    <script>
        // Load data from JSON file
        let flareData;

        // Helper functions
        function hierarchy(data, delimiter = "") {
            let root;
            const map = new Map();
            data.forEach(function find(data) {
                const { name } = data;
                if (map.has(name)) return map.get(name);
                const i = name.lastIndexOf(delimiter);
                map.set(name, data);
                if (i >= 0) {
                    find({ name: name.substring(0, i), children: [] }).children.push(data);
                    data.name = name.substring(i + 1);
                } else {
                    root = data;
                }
                return data;
            });
            return root;
        }

        function bilink(root) {
            const map = new Map(root.leaves().map(d => [id(d), d]));
            for (const d of root.leaves()) {
                d.incoming = [];
                d.outgoing = d.data.imports.map(i => [d, map.get(i)]);
            }
            for (const d of root.leaves()) {
                for (const o of d.outgoing) {
                    if (o[1]) o[1].incoming.push(o);
                }
            }
            return root;
        }

        function id(node) {
            return `${node.parent ? id(node.parent) + "" : ""}${node.data.name}`;
        }

        // Create the chart
        function createChart() {
            // Layout configuration
            const width = 900;
            const radius = width / 3.5;
            const RADIUS_PADDING = 50;
            
            // Font configuration
            const FONT_SIZE = 12;
            const HOVER_FONT_SIZE = 14;
            
            // Text positioning configuration
            const TEXT_OFFSET = 25;
            const TEXT_VERTICAL_OFFSET = "0.31em";
            
            // Curve configuration
            const CURVE_BETA = 0.75;
            
            // Line styling configuration
            const DEFAULT_STROKE_WIDTH = 1;
            const HOVER_STROKE_WIDTH = 3;
            
            // Legend configuration
            const LEGEND_ITEM_WIDTH = 120;
            const LEGEND_HEIGHT = 30;
            const LEGEND_CIRCLE_RADIUS = 8;
            const LEGEND_TEXT_OFFSET = 20;
            const LEGEND_TOP_MARGIN = 20;
            
            // Configuration variables for consistent rotation and positioning
            const ROTATION_DEGREES = 10;
            const ROTATION_RADIANS = ROTATION_DEGREES * Math.PI / 180;
            const BASE_ROTATION = Math.PI / 2;
            const TOTAL_ROTATION = BASE_ROTATION + ROTATION_RADIANS;
            
            // Text positioning thresholds (adjusted for rotation)
            const LEFT_START_ANGLE = Math.PI/2 + ROTATION_RADIANS;
            const LEFT_END_ANGLE = 3*Math.PI/2 + ROTATION_RADIANS;

            // Define color scheme for different categories
            const groupColors = ["#3498DB", "#E74C3C", "#2ECC71", "#F39C12", "#9B59B6"];

            // Colors
            const colornone = "#ccc";

            // Create data hierarchy
            const data = hierarchy(flareData);
            
            const tree = d3.cluster()
                .size([2 * Math.PI, radius - RADIUS_PADDING]);
            
            const root = tree(bilink(d3.hierarchy(data)
                .sort((a, b) => d3.ascending(a.height, b.height) || d3.ascending(a.data.name, b.data.name))));

            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", width)
                .attr("viewBox", [-width / 2, -width / 2, width, width])
                .attr("style", `max-width: 100%; height: auto; font: ${FONT_SIZE}px sans-serif;`);

            const node = svg.append("g")
                .selectAll()
                .data(root.leaves())
                .join("g")
                .attr("transform", d => `rotate(${d.x * 180 / Math.PI + ROTATION_DEGREES}) translate(${d.y},0)`)
                .append("text")
                .attr("dy", TEXT_VERTICAL_OFFSET)
                .attr("x", d => (d.x >= LEFT_START_ANGLE && d.x < LEFT_END_ANGLE) ? -TEXT_OFFSET : TEXT_OFFSET)
                .attr("text-anchor", d => (d.x >= LEFT_START_ANGLE && d.x < LEFT_END_ANGLE) ? "end" : "start")
                .attr("transform", d => (d.x >= LEFT_START_ANGLE && d.x < LEFT_END_ANGLE) ? "rotate(180)" : null)
                .text(d => d.data.name)
                .each(function(d) { d.text = this; })
                .on("mouseover", overed)
                .on("mouseout", outed)
                .call(text => text.append("title").text(d => `${id(d)}
${d.outgoing.length} outgoing
${d.incoming.length} incoming`));

            const line = d3.lineRadial()
                .curve(d3.curveBundle.beta(CURVE_BETA))
                .radius(d => d.y)
                .angle(d => d.x + TOTAL_ROTATION);

            // Group leaf nodes by their top-level category for visual organization
            const groupedNodes = d3.groups(root.leaves(), d => {
                let current = d;
                while (current.parent && current.parent !== root) {
                    current = current.parent;
                }
                return current.data.name;
            });

            // Process grouped nodes to create arc data for category visualization
            const groupData = groupedNodes.map(([category, nodes]) => {
                const angles = nodes.map(d => d.x).sort(d3.ascending);
                const avgAngle = (angles[0] + angles[angles.length - 1]) / 2;
                
                return {
                    label: category,
                    startAngle: angles[0],
                    endAngle: angles[angles.length - 1],
                    avgAngle: avgAngle
                };
            }).sort((a, b) => a.avgAngle - b.avgAngle);

            // Create visual arcs for each category group
            groupData.forEach((group, i) => {
                const labelRadius = radius - 40;
                const startAngle = group.startAngle + TOTAL_ROTATION;
                const endAngle = group.endAngle + TOTAL_ROTATION;
                
                const arc = d3.arc()
                    .innerRadius(labelRadius)
                    .outerRadius(labelRadius);
                
                const pathData = arc({
                    startAngle: startAngle,
                    endAngle: endAngle
                });
                
                svg.append("path")
                    .attr("d", pathData)
                    .attr("stroke", groupColors[i % groupColors.length])
                    .attr("stroke-width", 10)
                    .attr("fill", "none");
            });

            // Apply category colors to text labels
            svg.selectAll("text")
                .filter(function() { 
                    return this.parentNode.tagName === 'g';
                })
                .attr("fill", function(d) {
                    let current = d;
                    while (current.parent && current.parent !== root) {
                        current = current.parent;
                    }
                    const groupName = current.data.name;
                    const groupIndex = groupData.findIndex(group => group.label === groupName);
                    return groupColors[groupIndex % groupColors.length];
                });

            const link = svg.append("g")
                .attr("stroke", colornone)
                .attr("stroke-width", DEFAULT_STROKE_WIDTH)
                .attr("fill", "none")
                .selectAll()
                .data(root.leaves().flatMap(leaf => leaf.outgoing))
                .join("path")
                .style("mix-blend-mode", "multiply")
                .attr("d", ([i, o]) => line(i.path(o)))
                .each(function(d) { d.path = this; });

            // CREATE LEGEND
            const totalLegendWidth = groupData.length * LEGEND_ITEM_WIDTH;
            const legendStartX = -totalLegendWidth / 2;
            
            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(0, ${-width/2 + LEGEND_TOP_MARGIN})`);
            
            const legendItems = legend.selectAll(".legend-item")
                .data(groupData)
                .join("g")
                .attr("class", "legend-item")
                .attr("transform", (d, i) => `translate(${legendStartX + i * LEGEND_ITEM_WIDTH}, 0)`);
            
            legendItems.append("circle")
                .attr("cx", LEGEND_CIRCLE_RADIUS)
                .attr("cy", 0)
                .attr("r", LEGEND_CIRCLE_RADIUS)
                .attr("fill", (d, i) => groupColors[i % groupColors.length])
                .attr("stroke", "#333")
                .attr("stroke-width", 0.5);
            
            legendItems.append("text")
                .attr("x", LEGEND_TEXT_OFFSET)
                .attr("y", 0)
                .attr("dy", "0.35em")
                .attr("font-size", "12px")
                .attr("fill", "#333")
                .text(d => d.label);
            
            // Add legend interactivity
            legendItems
                .style("cursor", "pointer")
                .on("mouseover", function(event, d) {
                    d3.select(this).select("circle").attr("stroke-width", 2);
                    d3.select(this).select("text").attr("font-weight", "bold");
                    
                    const groupIndex = groupData.findIndex(group => group.label === d.label);
                    svg.selectAll("path")
                        .filter(function() {
                            return d3.select(this).attr("stroke") === groupColors[groupIndex % groupColors.length];
                        })
                        .attr("stroke-width", 15)
                        .attr("opacity", 1);
                })
                .on("mouseout", function(event, d) {
                    d3.select(this).select("circle").attr("stroke-width", 0.5);
                    d3.select(this).select("text").attr("font-weight", "normal");
                    
                    const groupIndex = groupData.findIndex(group => group.label === d.label);
                    svg.selectAll("path")
                        .filter(function() {
                            return d3.select(this).attr("stroke") === groupColors[groupIndex % groupColors.length];
                        })
                        .attr("stroke-width", 10)
                        .attr("opacity", 1);
                });

            function overed(event, d) {
                link.style("mix-blend-mode", null);
                d3.select(this).attr("font-weight", "bold").attr("font-size", HOVER_FONT_SIZE);
                
                // Color each incoming link based on its DESTINATION category
                d.incoming.forEach(linkData => {
                    const [source, target] = linkData;
                    
                    let current = target;
                    while (current.parent && current.parent !== root) {
                        current = current.parent;
                    }
                    const groupName = current.data.name;
                    const groupIndex = groupData.findIndex(group => group.label === groupName);
                    const categoryColor = groupColors[groupIndex % groupColors.length];
                    
                    d3.select(linkData.path).attr("stroke", categoryColor).attr("stroke-width", HOVER_STROKE_WIDTH).raise();
                });
                
                d3.selectAll(d.incoming.map(([d]) => d.text)).attr("font-weight", "bold").attr("font-size", HOVER_FONT_SIZE);
                
                // Color each outgoing link based on its destination category
                d.outgoing.forEach(linkData => {
                    const [source, target] = linkData;
                    
                    let current = target;
                    while (current.parent && current.parent !== root) {
                        current = current.parent;
                    }
                    const groupName = current.data.name;
                    const groupIndex = groupData.findIndex(group => group.label === groupName);
                    const categoryColor = groupColors[groupIndex % groupColors.length];
                    
                    d3.select(linkData.path).attr("stroke", categoryColor).attr("stroke-width", HOVER_STROKE_WIDTH).raise();
                });
                
                d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("font-weight", "bold").attr("font-size", HOVER_FONT_SIZE);
            }

            function outed(event, d) {
                link.style("mix-blend-mode", "multiply");
                d3.select(this).attr("font-weight", null).attr("font-size", FONT_SIZE);
                d3.selectAll(d.incoming.map(d => d.path)).attr("stroke", null).attr("stroke-width", DEFAULT_STROKE_WIDTH);
                d3.selectAll(d.incoming.map(([d]) => d.text)).attr("font-weight", null).attr("font-size", FONT_SIZE);
                d3.selectAll(d.outgoing.map(d => d.path)).attr("stroke", null).attr("stroke-width", DEFAULT_STROKE_WIDTH);
                d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("font-weight", null).attr("font-size", FONT_SIZE);
            }

            return svg.node();
        }

        // Load JSON data and initialize chart
        async function loadDataAndCreateChart() {
            try {
                // Load your JSON file
                const response = await fetch('gsi_data_725@1.json');
                flareData = await response.json();
                
                // Create and append the chart
                document.getElementById('chart').appendChild(createChart());
            } catch (error) {
                console.error('Error loading JSON data:', error);
                document.getElementById('chart').innerHTML = `
                    <div style="text-align: center; padding: 50px; color: #e74c3c;">
                        <h3>Error Loading Data</h3>
                        <p>Could not load the JSON file. Please make sure 'gsi_data_725@1.json' is in the same directory as this HTML file.</p>
                        <p>Error: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Initialize when page loads
        loadDataAndCreateChart();
    </script>
</body>
</html>