<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assessing GSI Research in Arid Climates</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
    }
    .legend text {
      text-transform: capitalize;
    }
  </style>
</head>
<body>

<h1>Assessing green stormwater infrastructure research and gaps in arid climates</h1>
<div id = "chart"></div>
  
<script>
const width = 600;
const radius = width / 2.8;
const RADIUS_PADDING = 60; // Reduced from 50
const FONT_SIZE = 10; // Reduced from 12
const HOVER_FONT_SIZE = 12; // Reduced from 14
const TEXT_OFFSET = 20; // Reduced from 25
const TEXT_VERTICAL_OFFSET = "0.31em";
const CURVE_BETA = 0.75;
const DEFAULT_STROKE_WIDTH = 1;
const HOVER_STROKE_WIDTH = 3;
const LEGEND_ITEM_WIDTH = 100; // Reduced from 120
const LEGEND_CIRCLE_RADIUS = 6; // Reduced from 8
const LEGEND_TEXT_OFFSET = 16; // Reduced from 20
const LEGEND_TOP_MARGIN = 15; // Reduced from 20
const ROTATION_DEGREES = 10;
const ROTATION_RADIANS = ROTATION_DEGREES * Math.PI / 180;
const BASE_ROTATION = Math.PI / 2;
const TOTAL_ROTATION = BASE_ROTATION + ROTATION_RADIANS;
const LEFT_START_ANGLE = Math.PI / 2 + ROTATION_RADIANS;
const LEFT_END_ANGLE = 3 * Math.PI / 2 + ROTATION_RADIANS;
const groupColors = ["#3498DB", "#E74C3C", "#2ECC71", "#F39C12", "#9B59B6"];
const colorin = "#00f";
const colorout = "#f00";
const colornone = "#ccc";

function id(node) {
  return `${node.parent ? id(node.parent) + "_" : ""}${node.data.name}`;
}

function hierarchy(data, delimiter = "_") {
  let root;
  const map = new Map();
  data.forEach(function find(d) {
    const { name } = d;
    if (map.has(name)) return map.get(name);
    const i = name.lastIndexOf(delimiter);
    map.set(name, d);
    if (i >= 0) {
      find({ name: name.substring(0, i), children: [] }).children.push(d);
      d.name = name.substring(i + 1);
    } else {
      root = d;
    }
    return d;
  });
  return root;
}

function bilink(root) {
  const map = new Map(root.leaves().map(d => [id(d), d]));
  for (const d of root.leaves()) {
    d.incoming = [];
    d.outgoing = d.data.imports.map(i => [d, map.get(i)]);
  }
  for (const d of root.leaves()) {
    for (const o of d.outgoing) {
      o[1].incoming.push(o);
    }
  }
  return root;
}

fetch("gsi-data.json")
  .then(res => res.json())
  .then(data => {
    const tree = d3.cluster().size([2 * Math.PI, radius - RADIUS_PADDING]);
    const root = tree(bilink(d3.hierarchy(hierarchy(data))
      .sort((a, b) => d3.ascending(a.height, b.height) || d3.ascending(a.data.name, b.data.name))));

    const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", width)
      .attr("viewBox", [-width / 2, -width / 2, width, width])
      .attr("style", `max-width: 100%; height: auto; font: ${FONT_SIZE}px sans-serif;`);

    const line = d3.lineRadial()
      .curve(d3.curveBundle.beta(CURVE_BETA))
      .radius(d => d.y)
      .angle(d => d.x + TOTAL_ROTATION);

    const groupedNodes = d3.groups(root.leaves(), d => {
      let current = d;
      while (current.parent && current.parent !== root) current = current.parent;
      return current.data.name;
    });

    const groupData = groupedNodes.map(([label, nodes]) => {
      const angles = nodes.map(d => d.x).sort(d3.ascending);
      return {
        label,
        startAngle: angles[0],
        endAngle: angles[angles.length - 1],
        avgAngle: (angles[0] + angles[angles.length - 1]) / 2
      };
    });

    groupData.forEach((group, i) => {
      const arc = d3.arc().innerRadius(radius - 40).outerRadius(radius - 40);
      svg.append("path")
        .attr("d", arc({
          startAngle: group.startAngle + TOTAL_ROTATION,
          endAngle: group.endAngle + TOTAL_ROTATION
        }))
        .attr("stroke", groupColors[i % groupColors.length])
        .attr("stroke-width", 10)
        .attr("fill", "none");
    });

    const link = svg.append("g")
      .attr("stroke", colornone)
      .attr("stroke-width", DEFAULT_STROKE_WIDTH)
      .attr("fill", "none")
      .selectAll("path")
      .data(root.leaves().flatMap(leaf => leaf.outgoing))
      .join("path")
      .style("mix-blend-mode", "multiply")
      .attr("d", ([i, o]) => line(i.path(o)))
      .each(function (d) { d.path = this; });

    function overed(event, d) {
      link.style("mix-blend-mode", null);
      d3.select(this).attr("font-weight", "bold").attr("font-size", HOVER_FONT_SIZE);
      
      // Color each incoming link based on its DESTINATION category
      d.incoming.forEach(linkData => {
        const [source, target] = linkData;
        
        // Find the destination node's category
        let current = target;
        while (current.parent && current.parent !== root) {
          current = current.parent;
        }
        const groupName = current.data.name;
        const groupIndex = groupData.findIndex(group => group.label === groupName);
        const categoryColor = groupColors[groupIndex % groupColors.length];
        
        // Apply the destination category color to this specific link
        d3.select(linkData.path).attr("stroke", categoryColor).attr("stroke-width", HOVER_STROKE_WIDTH).raise();
      });
      
      d3.selectAll(d.incoming.map(([d]) => d.text)).attr("font-weight", "bold").attr("font-size", HOVER_FONT_SIZE);
      
      // Color each outgoing link based on its destination category
      d.outgoing.forEach(linkData => {
        const [source, target] = linkData;
        
        // Find the destination node's category
        let current = target;
        while (current.parent && current.parent !== root) {
          current = current.parent;
        }
        const groupName = current.data.name;
        const groupIndex = groupData.findIndex(group => group.label === groupName);
        const categoryColor = groupColors[groupIndex % groupColors.length];
        
        // Apply the destination category color to this specific link
        d3.select(linkData.path).attr("stroke", categoryColor).attr("stroke-width", HOVER_STROKE_WIDTH).raise();
      });
      
      d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("font-weight", "bold").attr("font-size", HOVER_FONT_SIZE);
    }
    function outed(event, d) {
      link.style("mix-blend-mode", "multiply");
      d3.select(this).attr("font-weight", null).attr("font-size", FONT_SIZE);
      d3.selectAll(d.incoming.map(d => d.path)).attr("stroke", colornone).attr("stroke-width", DEFAULT_STROKE_WIDTH);
      d3.selectAll(d.outgoing.map(d => d.path)).attr("stroke", colornone).attr("stroke-width", DEFAULT_STROKE_WIDTH);
      d3.selectAll(d.incoming.map(([d]) => d.text)).attr("font-weight", null).attr("font-size", FONT_SIZE);
      d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("font-weight", null).attr("font-size", FONT_SIZE);
    }

    svg.append("g")
      .selectAll("text")
      .data(root.leaves())
      .join("g")
      .attr("transform", d => `rotate(${d.x * 180 / Math.PI + ROTATION_DEGREES}) translate(${d.y},0)`)
      .append("text")
      .attr("dy", TEXT_VERTICAL_OFFSET)
      .attr("x", d => (d.x >= LEFT_START_ANGLE && d.x < LEFT_END_ANGLE) ? -TEXT_OFFSET : TEXT_OFFSET)
      .attr("text-anchor", d => (d.x >= LEFT_START_ANGLE && d.x < LEFT_END_ANGLE) ? "end" : "start")
      .attr("transform", d => (d.x >= LEFT_START_ANGLE && d.x < LEFT_END_ANGLE) ? "rotate(180)" : null)
      .text(d => d.data.name)
      .each(function (d) { d.text = this; })
      .on("mouseover", overed)
      .on("mouseout", outed)
      .call(text => text.append("title").text(d => `${id(d)}\n${d.outgoing.length} outgoing\n${d.incoming.length} incoming`))
      .attr("fill", function (d) {
        let current = d;
        while (current.parent && current.parent !== root) current = current.parent;
        const groupIndex = groupData.findIndex(group => group.label === current.data.name);
        return groupColors[groupIndex % groupColors.length];
      });

    // Legend
    const totalLegendWidth = groupData.length * LEGEND_ITEM_WIDTH;
    const legendStartX = -totalLegendWidth / 2;

    const legend = svg.append("g")
      .attr("class", "legend")
      .attr("transform", `translate(0, ${-width / 2 + LEGEND_TOP_MARGIN})`);

    const legendItems = legend.selectAll(".legend-item")
      .data(groupData)
      .join("g")
      .attr("class", "legend-item")
      .attr("transform", (d, i) => `translate(${legendStartX + i * LEGEND_ITEM_WIDTH}, 0)`)
      .on("mouseover", (event, d) => {
        const index = groupData.findIndex(g => g.label === d.label);
        svg.selectAll("path")
          .filter(function () {
            return d3.select(this).attr("stroke") === groupColors[index % groupColors.length];
          })
          .attr("stroke-width", 5)
          .raise();
      })
      .on("mouseout", () => {
        svg.selectAll("path")
          .attr("stroke-width", DEFAULT_STROKE_WIDTH);
      });

    legendItems.append("circle")
      .attr("cx", LEGEND_CIRCLE_RADIUS)
      .attr("cy", 0)
      .attr("r", LEGEND_CIRCLE_RADIUS)
      .attr("fill", (d, i) => groupColors[i % groupColors.length])
      .attr("stroke", "#333")
      .attr("stroke-width", 0.5);

    legendItems.append("text")
      .attr("x", LEGEND_TEXT_OFFSET)
      .attr("y", 0)
      .attr("dy", "0.35em")
      .attr("font-size", "12px")
      .attr("fill", "#333")
      .text(d => d.label);

    document.getElementById("chart").appendChild(svg.node());
  });
</script>
</body>
</html>






