<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assessing GSI Research in Arid Climates</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
    }
    .legend text {
      text-transform: capitalize;
    }
  </style>
</head>
<body>

<h1>Assessing green stormwater infrastructure research and gaps in arid climates</h1>
<p>This chart shows relationships among research papers involving green stormwater infrastructure (GSI) and arid environments. Hover a class to reveal the paper (<b style="color: #f00;">outgoing</b> edges) and relevant information related to the paper (<b style="color: #00f;">incoming</b> edges).</p>
<div id="chart"></div>

<script>
const width = 900;
const radius = width / 2.8;
const RADIUS_PADDING = 50;
const FONT_SIZE = 12;
const HOVER_FONT_SIZE = 14;
const TEXT_OFFSET = 25;
const TEXT_VERTICAL_OFFSET = "0.31em";
const CURVE_BETA = 0.75;
const DEFAULT_STROKE_WIDTH = 1;
const HOVER_STROKE_WIDTH = 3;
const ROTATION_DEGREES = 10;
const ROTATION_RADIANS = ROTATION_DEGREES * Math.PI / 180;
const BASE_ROTATION = Math.PI / 2;
const TOTAL_ROTATION = BASE_ROTATION + ROTATION_RADIANS;
const LEFT_START_ANGLE = Math.PI / 2 + ROTATION_RADIANS;
const LEFT_END_ANGLE = 3 * Math.PI / 2 + ROTATION_RADIANS;
const groupColors = ["#3498DB", "#E74C3C", "#2ECC71", "#F39C12", "#9B59B6"];
const colorin = "#00f";
const colorout = "#f00";
const colornone = "#ccc";

function id(node) {
  return `${node.parent ? id(node.parent) + "_" : ""}${node.data.name}`;
}

function hierarchy(data, delimiter = "_") {
  let root;
  const map = new Map();
  data.forEach(function find(d) {
    const { name } = d;
    if (map.has(name)) return map.get(name);
    const i = name.lastIndexOf(delimiter);
    map.set(name, d);
    if (i >= 0) {
      find({ name: name.substring(0, i), children: [] }).children.push(d);
      d.name = name.substring(i + 1);
    } else {
      root = d;
    }
    return d;
  });
  return root;
}

function bilink(root) {
  const map = new Map(root.leaves().map(d => [id(d), d]));
  for (const d of root.leaves()) {
    d.incoming = [];
    d.outgoing = d.data.imports.map(i => [d, map.get(i)]);
  }
  for (const d of root.leaves()) {
    for (const o of d.outgoing) {
      o[1].incoming.push(o);
    }
  }
  return root;
}

fetch("gsi-data.json")
  .then(res => res.json())
  .then(data => {
    const tree = d3.cluster().size([2 * Math.PI, radius - RADIUS_PADDING]);
    const root = tree(bilink(d3.hierarchy(hierarchy(data))
      .sort((a, b) => d3.ascending(a.height, b.height) || d3.ascending(a.data.name, b.data.name))));

    const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", width)
      .attr("viewBox", [-width / 2, -width / 2, width, width])
      .attr("style", `max-width: 100%; height: auto; font: ${FONT_SIZE}px sans-serif;`);

    const line = d3.lineRadial()
      .curve(d3.curveBundle.beta(CURVE_BETA))
      .radius(d => d.y)
      .angle(d => d.x + TOTAL_ROTATION);

    const groupedNodes = d3.groups(root.leaves(), d => {
      let current = d;
      while (current.parent && current.parent !== root) current = current.parent;
      return current.data.name;
    });

    const groupData = groupedNodes.map(([label, nodes]) => {
      const angles = nodes.map(d => d.x).sort(d3.ascending);
      return {
        label,
        startAngle: angles[0],
        endAngle: angles[angles.length - 1],
        avgAngle: (angles[0] + angles[angles.length - 1]) / 2
      };
    });

    const link = svg.append("g")
      .attr("stroke", colornone)
      .attr("stroke-width", DEFAULT_STROKE_WIDTH)
      .attr("fill", "none")
      .selectAll("path")
      .data(root.leaves().flatMap(leaf => leaf.outgoing))
      .join("path")
      .style("mix-blend-mode", "multiply")
      .attr("d", ([i, o]) => line(i.path(o)))
      .each(function (d) { d.path = this; });

    function overed(event, d) {
      link.style("mix-blend-mode", null);
      d3.select(this).attr("font-weight", "bold").attr("font-size", HOVER_FONT_SIZE);

      d.incoming.forEach(([source, target]) => {
        let current = target;
        while (current.parent && current.parent !== root) current = current.parent;
        const groupIndex = groupData.findIndex(g => g.label === current.data.name);
        d3.select(source.path).attr("stroke", groupColors[groupIndex]).attr("stroke-width", HOVER_STROKE_WIDTH).raise();
      });

      d.outgoing.forEach(([source, target]) => {
        let current = target;
        while (current.parent && current.parent !== root) current = current.parent;
        const groupIndex = groupData.findIndex(g => g.label === current.data.name);
        d3.select(source.path).attr("stroke", groupColors[groupIndex]).attr("stroke-width", HOVER_STROKE_WIDTH).raise();
      });

      d3.selectAll(d.incoming.map(([d]) => d.text)).attr("font-weight", "bold").attr("font-size", HOVER_FONT_SIZE);
      d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("font-weight", "bold").attr("font-size", HOVER_FONT_SIZE);
    }

    function outed(event, d) {
      link.style("mix-blend-mode", "multiply");
      d3.select(this).attr("font-weight", null).attr("font-size", FONT_SIZE);
      d3.selectAll(d.incoming.map(d => d.path)).attr("stroke", colornone).attr("stroke-width", DEFAULT_STROKE_WIDTH);
      d3.selectAll(d.outgoing.map(d => d.path)).attr("stroke", colornone).attr("stroke-width", DEFAULT_STROKE_WIDTH);
      d3.selectAll(d.incoming.map(([d]) => d.text)).attr("font-weight", null).attr("font-size", FONT_SIZE);
      d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("font-weight", null).attr("font-size", FONT_SIZE);
    }

    svg.append("g")
      .selectAll("text")
      .data(root.leaves())
      .join("g")
      .attr("transform", d => `rotate(${d.x * 180 / Math.PI + ROTATION_DEGREES}) translate(${d.y},0)`)
      .append("text")
      .attr("dy", TEXT_VERTICAL_OFFSET)
      .attr("x", d => (d.x >= LEFT_START_ANGLE && d.x < LEFT_END_ANGLE) ? -TEXT_OFFSET : TEXT_OFFSET)
      .attr("text-anchor", d => (d.x >= LEFT_START_ANGLE && d.x < LEFT_END_ANGLE) ? "end" : "start")
      .attr("transform", d => (d.x >= LEFT_START_ANGLE && d.x < LEFT_END_ANGLE) ? "rotate(180)" : null)
      .text(d => d.data.name)
      .each(function (d) { d.text = this; })
      .on("mouseover", overed)
      .on("mouseout", outed)
      .call(text => text.append("title").text(d => `${id(d)}\n${d.outgoing.length} outgoing\n${d.incoming.length} incoming`));

    document.getElementById("chart").appendChild(svg.node());
  });
</script>
</body>
</html>
